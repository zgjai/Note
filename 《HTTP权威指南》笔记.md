#第二章 URL与资源
1. URL语法通用格式  
	大多数URL方案的URL语法都建立在这个由9部分构成的通用格式上：  

		<scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag>

	URL最重要的3个部分是方案（scheme）、主机（host）和路径（path）。  

	|   组件 |  描述   |   默认值  |
	| ----  |:------| :---------:|
	|  方案  |	 访问服务器以获取资源时要使用哪种协议   |  无   |
	|  用户  |  某些方案访问资源时需要的用户名 | 匿名 |
	|  密码  |  用户名后面可能要包含的密码，中间由冒号（:）分割  | E-mail地址 |
	|  主机  |  资源宿主服务器的主机名或点分IP地址  |  无  |
	|  端口  |  资源宿主服务器正在监听的端口号。很多方案都有默认的端口号（HTTP的默认端口号是80）|  每个方案特有|
	|  路径  |  服务器上资源的本地名，由一个斜杠（/）将其与前面的URL组件分隔开。路径组件的语法是与服务器和方案有关的。  |  无  |
	|  参数  |  某些方案会用这个组件来指定输入参数。参数为名/值对。URL中可以包含多个参数字段，它们相互之间以及与路径的其余部分之间用(;)分割  |  无  |
	|  查询  |  某些方案会用这个组件传递参数以激活应用程序。  |  无  |
	|  片段  |  一小片或一部分资源的名字  |  无  |
</frag>



#第三章 HTTP报文
1. 报文流  
	HTTP报文是在HTTP应用程序之间发送的数据块。这些数据块以一些文本形式的元信息开头，这些信息描述了报文的内容及含义，后面跟着可选的数据部分。

2. 报文的组成部分  
	每条HTTP报文都包含一条来自客户端的请求，或者一条来自服务器的响应。它们都由三个部分组成：对报文进行描述的起始行、包含属性的首部块，以及可选的、包含数据的主体部分。

3. 报文格式  
	请求报文的格式：

		<method> <request-URL> <version>
		<headers>
		<entity-body>

	响应报文的格式：

		<version> <status> <reason-phrase>
		<headers>
		<entity-body>

	各个部分的简述：  
	* 方法(method)  
		客户端希望服务器对资源执行的动作。比如GET、HEAD、POST等。
	* 请求URL(request-URL)    
		命名了所请求资源，或者URL路径组件的完整URL。
	* 版本(version)   
		报文所使用的HTTP版本，格式是这样的：  

			HTTP/<major>.<minor>

		major是主要版本号，minor是次要版本号

	* 状态码(status-code)  
		这三位数字描述了请求过程中所发生的情况。 状态码的分类如下：

	| 整体范围 | 已定义范围 | 分类 |
	| ----    |:-----: | ---------:|
	| 100~199 | 100~101 | 信息提示 |
	| 200~299 | 200~206 | 成功 |
	| 300~399 | 300~305 | 重定向 |
	| 400~499 | 400~415 | 客户端错误 |
	| 500~599 | 500~505 | 服务器错误 |

	* 原因短语(reason-phrase)  
		数字状态码的可读版本，包含行终止序列之前的所有文本。  
	* 首部(header)    
		可以有零个或多个首部，每个首部都是一个键值对。首部是由一个空行结束的，表示首部列表的结束和实体主体部分的开始。
	* 实体的主体部分(entity-body)  
		实体的主体部分包含一个由任意数据组成的数据块。并不是所有的报文都包含实体的主体部分，有时，报文只是以一个CRLF结束。

4. 起始行
	所有的HTTP报文都以一个起始行作为一个开始。请求报文的起始行说明了要做些什么，响应报文的起始行说明发生了什么。
	* 请求行  
		请求报文请求服务器对资源进行一些操作。请求行包含了一个方法、一个请求的URL和HTTP的版本。所有这些字段均以空格分隔。
	* 响应行  
		响应报文承载了状态信息和操作产生的所有结果数据，将其返回给客户端。响应行包含了HTTP版本、状态码和描述操作状态的文本形式的原因短语。
	* 方法  
		请求的起始行以方法作为开始，方法用来告知服务器要做些什么。  
		常用的HTTP方法：

	| 方法 | 描述 | 是否包含主体 |
	| --- |:----|:-----------:|
	| GET | 从服务器获取一份文档 | 否 |
	| HEAD | 只从服务器获取文档的首部 | 否 |
	| POST | 向服务器发送需要处理的数据 | 是 |
	| PUT | 将请求的主体部分存储在服务器上 | 是 |
	| TRACE | 对可能经过代理服务器传送到服务器上去的报文进行跟踪 | 否 |
	| OPTIONS | 决定可以在服务器上执行哪些方法 | 否 |
	| DELETE | 从服务器上删除一份文档 | 否 |

	* 状态码  
		方法是用来告诉服务器做什么事情的，状态码则是用了告诉客户端，发生了什么事情。
	* 原因短语  
		原因短语是响应起始行中的最后一个组件。它为状态码提供了文本形式的解释。
	* 版本号  
		版本号会以HTTP/x.y的形式出现在请求和响应报文的起始行中。

5. 首部  
	HTTP首部字段向请求和响应报文中添加了一些附加信息，本质上来说，他们只是一些名/值对的列表。

	* 首部分类  
		* 通用首部  
			既可以出现在请求报文中，也可以出现在响应报文中  
			通用的信息性首部：

			| 首部 | 描述 |  
			|:-----|:-------|
			| Connection | 允许客户端和服务器指定与请求/响应连接有关的选项 |
			| Date | 提供日期和时间标志，说明报文是什么时候创建的 |
			| MIME-Version | 给出了发送端使用的MIME版本 |
			| Trailer | 如果报文采用了分块传输编码(chunked transfer encoding)方式，就可以用这个首部列出位于报文拖鞋(trailer)部分的首部集合 |
			| Transfer-Encoding | 告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式 |
			| Update | 给出了发送端可能想要“升级”使用的新版本或协议 |
			| Via | 显示了报文经过的中间节点（代理、网关）|

			通用缓存首部：

			| 首部 | 描述 |
			|:---|:---|
			| Cache-Control | 用于随报文传送缓存指示 |
			| Pragma | 另一种随报文传送指示的方式，但并不专用于缓存 |  

		* 请求首部  
			提供更多有关请求的信息    
			请求的信息性首部：

			| 首部 | 描述 |
			|-----|:-----|
			| Client-IP | 提供了运行客户端的机器的IP地址 |
			| From | 提供了客户端用户的E-mail地址 |
			| Host | 给出了接收请求的服务器的主机名和端口号 |
			| Referer | 提供了包含当前请求URI的文档的URL |
			| UA-Color | 提供了与客户端显示器的显示颜色有关的信息 |
			| UA-CPU | 给出了客户端CPU的类型或制造商 |
			| UA-Disp | 提供了与客户端显示器（屏幕）能力有关的信息 |
			| UA-OS | 给出了运行在客户端机器上的操作系统名称及版本 |
			| UA-Pixels | 提供了客户端显示器的像素信息 |
			| User-Agent | 将发起请求的应用程序名称告知服务器 |  

			Accept首部：

			| 首部 | 描述 |
			|-----|:-----|
			| Accept | 告诉服务器能够发送哪些媒体类型 |
			| Accept-Charset | 告诉服务器能够发送哪些字符集 |
			| Accept-Encoding | 告诉服务器能够发送哪些编码方式 |
			| Accept-Language | 告诉服务器能够发送哪些语言 |
			| TE | 告诉服务器可以使用哪些扩展传输编码 |

			条件请求首部：

			| 首部 | 描述 |
			|------|:------|
			| Except | 允许客户端列出某请求所要求的服务器行为 |
			| If-Match | 如果实体标记与文档当前的实体标记相匹配，就获取这份文档 |
			| If-Modified-Since | 除非在某个指定的日期之后资源被修改，否则就限制这个请求 |
			| If-None-Match | 如果实体标记与文档当前的实体标记不相符，就获取这份文档 |
			| If-Range | 允许对文档的某个范围进行条件请求 |
			| If-Unmodified-Since | 除非在某个指定日期之后资源没有被修改过，否则就限制这个请求 |
			| Range | 如果服务器支持范围请求，就请求资源的指定范围 |

			安全请求首部：  

			| 首部 | 描述 |
			|-----|:-----|
			| Authorization | 包含了客户端提供给服务器，以便对其自身进行认证的数据 |
			| Cookie | 客户端用它向服务器传送一个令牌--它并不是真正的安全首部，但确实隐含了安全功能 |
			| Cookie2 | 用来说明请求端支持的cookie版本 |

			代理请求首部：  

			| 首部 | 描述 |
			|-----|:-----|
			| Max-Forward | 在通往源端服务器的路径上，将请求转发给其他代理或网关的最大次数--与TRACE方法一同使用 |
			| Proxy-Authorization | 与Authorization首部相同，但这个首部是在与代理进行认证时使用的 |
			| Proxy-Connection | 与Connection首部相同，但这个首部是在与代理建立连接时使用的 |

		* 响应首部  
			提供更多有关响应的信息  
			响应的信息性首部：

			| 首部 | 描述 |
			|-----|:-----|
			| Age | （从最初创建开始）响应持续时间 |
			| Public | 服务器为其资源支持的请求方法列表 |
			| Retry-After | 如果资源不可用的话，在此日期或时间重试 |
			| Server | 服务器应用程序软件的名称和版本 |
			| Title | 对HTML文档来说，就是HTML文档的源端给出的标题 |
			| Warning | 比原因短语更详细一些的警告报文 |  

			协商首部：

			| 首部 | 描述 |  
			|-----|:-----|  
			| Accept-Ranges | 对此资源来说，服务器可接受的范围类型 |
			| Vary | 服务器查看的其他首部的列表，可能会使响应发生变化 |

			安全响应首部：

			| 首部 | 描述 |
			|-----|:-----|
			| Proxy-Authenticate | 来自代理的对客户端的质询列表 |
			| Set-Cookie | 可以在客户端设置一个令牌，以便服务器对客户端进行标识 |
			| Set-Cookie2 | 与Set-Cookie相似 |
			| WWW-Authenticate | 来自服务器对客户端的质询列表 |


		* 实体首部  
			描述主体的长度和内容，或者资源自身  
			实体的信息性首部：

			| 首部 | 描述 |
			|-----|:-----|
			| Allow | 列出了可以对此实体执行的请求方法 |
			| Location | 告知客户端实体实际上位于何处；用于将接收端定向到资源的位置上去 |

			内容首部：

			| 首部 | 描述 |
			|-----|:-----|
			| Content-Base | 解析主体中的相对URL时使用的基础URL |
			| Content-Encoding | 对主体执行的任意编码方式 |
			| Content-Language | 理解主体时最适宜使用的自然语言 |
			| Content-Length | 主体的长度或尺寸 |
			| Content-Location | 资源实际所处的位置 |
			| Content-MD5 | 主体的MD5校验和 |
			| Content-Range | 在整个资源中此实体表示的字节范围 |
			| Content-Type | 这个主体的对象类型 |

			实体缓存首部：

			| 首部 | 描述 |
			|-----|:-----|
			| ETag | 与此实体相关的实体标记 |
			| Expires | 实体不再有效，要从原始的源端再次获取此实体的日期和时间 |
			| Last-Modified | 这个实体最后一次被修改的日期和时间 |


		* 扩展首部  
			规范中没有定义的新首部

	* 首部延续行  
		将长的首部行分为多行可以提高可读性，多出来的每行前面至少要有一个空格或制表符。
		示例：

			HTTP/1.0 200 OK
			Content-Type: image/gif
			Content-Length: 8572
			Server: Test Server
				Version 1.0



#第四章 连接管理

 1. 常见的TCP套接字接口  
 	* s = socket(\<parameters>)   
 		创建一个新的、未命名、未关联的套接字

 	* bind(s, \<local IP:port>)  
 		将套接字跟本地一个端口号和接口绑定

 	* connect(s, \<remote IP:port>)  
 		创建一条连接本地套接字与远程主机及端口的连接

 	* listen(s, ...)  
 		标识一个本地套接字，使其可以合法接受连接

 	* s2 = accept(s)  
 		等待建立一条到本地端口的连接

 	* n = read(s, buffer, n)  
 		尝试从缓冲区向套接字读取n个字节

 	* n = write(s, buffer, n)  
 		尝试从套接字向缓冲区写入n个字节

 	* close(s)  
 		完全关闭TCP连接

 	* shutdown(s, \<side>)  
 		只关闭TCP连接的输入或输出端

 	* getsockopt(s, ...)  
 		读取某个内部套接字配置选项的值

 	* setsockopt(s, ...)  
 		修改某个内部套接字配置选项的值

2. TCP客户端和服务器通过TCP套接字接口通信的过程  

	| 客户端 | 服务端 |
	|-----|-----|
	|  | (S1)创建新的套接字(socket) |
	|  | (S2)将套接字绑定到端口80上去(bind) |
	|  | (S3)允许套接字进行连接(listen) |
	|  | (S4)等待连接(accept) |
	| (C1)获取IP地址和端口号 |  |
	| (C2)创建新的套接字(socket) |  |
	| (C3)连接到服务器IP:port上去(connect) |  |
	|  | (S5)通知应用程序有连接到来 |
	| (C4)连接成功 | (S6)开始读取请求(read) |
	| (C5)发送HTTP请求(write) |  |
	| (C6)等待HTTP响应(read) | (S7)处理HTTP请求报文 |
	|  | (S8)回送HTTP响应(write) |
	| (C7)处理HTTP响应 | (S9)关闭连接(close) |
	| (C8)关闭连接(close) |  |


3. HTTP连接的处理  

	a. 常被误解的Connection首部   
		在某些情况下，两个相邻的HTTP应用程序会为它们共享的连接应用一组选项。HTTP的Connection首部字段中有一个由逗号分隔的连接标签列表，这些标签为此连接指定了一些不会传播到其他连接中去的选项。  
	Connection首部可以承载3种不同类型的标签：  
	* HTTP首部字段名，列出了只与此连接有关的首部  
	* 任意标签值，用于描述此连接的非标准选项  	
	* 值close，说明操作完成之后需关闭这条持久连接  

	b. 并行连接  
		通过多条TCP连接发起并发的HTTP请求。包含嵌入对象的组合页面如果能通过并行连接克服单条连接的空载时间和带宽限制，加载速度也会有所提高。因为TCP时延可以重叠起来，而且如果单条连接没有充分利用客户端的因特网带宽，可以将未用带宽分配来装载其它对象。但并行连接并不能保证一定会更快。客户端的网络带宽不足时，一条连接就可能会耗尽所有可用带宽。而且，打开大量连接会消耗很多内存资源，从而导致自身的性能问题。实际上，浏览器确实使用了并行连接，但它们会将并行连接的总数限制为一个较小的值（通常为4个）。

	c. 持久连接  
		Web客户端经常会打开同一个站点的连接，初始化了对某服务器HTTP请求的应用程序很可能会在不久的将来对那台服务器发起更多的请求。这种性质被称为站点局部性。因此，HTTP/1.1允许HTTP设备在事务处理结束后将TCP连接保持在打开状态，以便为未来的HTTP请求重用现存的连接。在事务处理结束后仍然保持在打开状态的TCP连接被称为持久连接。非持久连接会在每个事务结束之后关闭。持久连接会在不同事务之间保持打开状态，直到客户端或服务器决定将其关闭为止。重用已对目标服务器打开的空闲持久连接，就可以避免缓慢的连接建立阶段。而且，已经打开的连接还可以避免慢启动的拥塞适应阶段，以便更快速地进行数据的传输。  

		持久连接与并行连接配合使用的方式可能是最高效的。现在，很多Web应用程序都会打开少量的并行连接，其中的每一个都是持久连接。持久连接有两种类型：比较老的HTTP/1.0 + "keep-alive"连接，以及现代的HTTP/1.1 "persistent"连接。
